import { isAudioNode } from 'standardized-audio-context/src/guards/audio-node';
import { isDelayNode } from 'standardized-audio-context/src/guards/delay-node';
import { IAudioNode, IAudioParam } from 'standardized-audio-context/src/interfaces/index';
import { TContext, TDetectCyclesFactory } from 'standardized-audio-context/src/types/index';

export const createDetectCycles: TDetectCyclesFactory = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {
    return function detectCycles<T extends TContext>(chain: IAudioNode<T>[], nextLink: IAudioNode<T> | IAudioParam): IAudioNode<T>[][] {
        const audioNode = isAudioNode(nextLink) ? nextLink : <IAudioNode<T>>getValueForKey(audioParamAudioNodeStore, nextLink);

        if (isDelayNode(audioNode)) {
            return [];
        }

        if (chain[0] === audioNode) {
            return [chain];
        }

        if (chain.includes(audioNode)) {
            return [];
        }

        const { outputs } = getAudioNodeConnections(audioNode);

        return Array.from(outputs)
            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))
            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);
    };
};
